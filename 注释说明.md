在 Shell 脚本（如 sh 或 bash）中编写规范、清晰的注释是保证代码可读性和可维护性的关键。虽然不像 Python 的 PEP 8 那样有强制性的官方标准，但社区已经形成了一套广泛认可的最佳实践。

## 1. **文件头注释 (File Header)**

---

文件头是脚本的“身份证”，是整个脚本中最重要的注释块。它应该放在脚本的最顶部（仅次于 shebang），提供脚本的元信息。

一个优秀的文件头应该包含以下内容：

- Shebang: `#!/bin/bash` 或 `#!/bin/sh`。这虽然不是注释，但必须是文件的第一行，用于指定解释器。
- 脚本描述 (Description): 简明扼要地说明这个脚本的用途和功能。
- 作者 (Author): 脚本的创建者。
- 版本 (Version): 版本号，方便追踪变更。
- 创建/修改日期 (Date): 脚本的生命周期记录。
- 使用方法 (Usage): 如何运行此脚本，包括必要的参数和选项。这是非常重要的一部分。
- 依赖项 (Dependencies): 脚本运行前需要安装的工具或依赖（如 `jq`, `curl` 等）。
- 许可证 (License): 版权信息，如 MIT, GPLv3 等。

**规范示例**

你可以使用一种醒目的、一致的风格来组织文件头，例如：

```bash
#!/bin/bash

### =================================================================================
# @名称:         backup_database.sh
# @功能描述:     一个用于每日备份 PostgreSQL 数据库、压缩备份文件并上传到 S3 的脚本。
# @作者:         张三 (zhang.san@example.com)
# @版本:         1.1.0
# @创建日期:     2025-07-20
# @修改日期:     2025-07-21
#
# @使用方法:     ./backup_database.sh [参数]
# @参数选项:
#   -h, --help   显示此帮助信息。
#   -c, --config 文件路径  指定配置文件的路径 (默认: /etc/backup.conf)
#
# @依赖:         postgresql-client, aws-cli, gzip
# @许可证:       MIT
### =================================================================================

# --- 脚本由此开始 ---
```

## 2. **函数注释 (Function Comments)**

每个函数都应该有一个紧邻其上方的注释块，解释这个函数的功能、参数和返回值。这极大地降低了他人（或未来的你）理解代码的难度。

推荐使用类似 Javadoc 或 Doxygen 的风格，使用 @ 标签来标识不同部分。

- @描述 (@description): 描述函数做什么。
- @参数 (@param): 描述每个参数的含义和用途。
- @返回值 (@return): 描述函数的输出或返回值。0 通常表示成功，非 0 表示失败。
- @示例 (@example): 提供一个使用示例。

**规范示例**

```bash
### === 使用 gzip 压缩指定的文件 === ###
#
# @描述
#   本函数接收一个文件路径作为输入，检查文件是否存在，然后使用 gzip
#   进行压缩。成功压缩后，源文件将被删除。
#
# @参数 $1: 字符串 - 需要被压缩的文件的完整路径。
#
# @返回值
#   成功返回 0。
#   如果文件不存在，返回 1。
#   如果 gzip 命令执行失败，返回 2。
#
# @示例
#   _compress_file "/tmp/db_backup.sql"
###
_compress_file() {
    local file_path="$1"

    if [[ ! -f "$file_path" ]]; then
        echo "错误：文件不存在 '$file_path'" >&2
        return 1
    fi

    if gzip "$file_path"; then
        echo "成功压缩: ${file_path}.gz"
        return 0
    else
        echo "错误：压缩文件失败 '$file_path'" >&2
        return 2
    fi
}
```

## 3. **代码块注释 (Block Comments)**

当有一段比较复杂的逻辑时，应该在代码块开始前添加注释，解释这段代码的**“为什么（Why）”和“做什么（What）”，而不是“怎么做（How）”**。代码本身应该解释“怎么做”。

**规范示例**

```bash
# ==================================================
# S3 上传逻辑
# ==================================================
# 我们需要使用当前日期来构建 S3 存储路径，以便将备份文件按天分文件夹存放。
# 这样做可以让后续查找和恢复备份时更加方便。
# 如果网络不稳定，脚本将尝试最多3次上传。

S3_PATH="s3://${S3_BUCKET}/backups/$(date +%Y-%m-%d)/${BACKUP_FILENAME}.gz"
RETRY_COUNT=0
MAX_RETRIES=3

until aws s3 cp "${BACKUP_FILENAME}.gz" "${S3_PATH}"; do
    RETRY_COUNT=$((RETRY_COUNT + 1))
    if [[ ${RETRY_COUNT} -ge ${MAX_RETRIES} ]]; then
        echo "错误：尝试 ${MAX_RETRIES} 次后，上传到 S3 仍然失败。" >&2
        exit 1
    fi
    echo "上传失败。5秒后重试... (${RETRY_COUNT}/${MAX_RETRIES})"
    sleep 5
done
```

## 4. **行内注释 (Inline Comments)**

行内注释用于解释单行代码中不明显的部分。它应该简短、精确，并与代码保持适当的距离。

原则：只在必要时使用。如果代码本身已经足够清晰，就不要画蛇添足。

**规范示例**

**好的例子** (解释意图):

```bash
# 检查脚本是否以 root 身份运行 (root用户的有效UID为0)
if [[ $EUID -ne 0 ]]; then
   echo "本脚本必须以 root 身份运行" 
   exit 1 # 使用非零状态码退出，表示发生了错误
fi

# 使用 -r 防止反斜杠转义，-d '' 确保正确处理文件的最后一行
while IFS= read -r -d '' file; do
    # ...
done < <(find . -name "*.log" -print0)
```

**不好的例子** (废话注释):

```bash
# 差: 这句注释是多余的，代码本身已经足够清晰
i=$((i + 1)) # 将 i 的值加 1
```

**总结与最佳实践**

1. 无论使用中文还是英文，核心原则不变：
2. 一致性是王道: 在整个项目中统一使用一种风格。
3. 注释“为什么”，而不是“是什么”: 你的代码展示了“是什么”，注释应该解释“为什么”需要这段代码。
4. 与代码同步: 修改代码后，务必检查并更新相关注释。
5. 清晰简洁: 用最简单的话把意图说清楚。
6. 善用空行: 使用空行来分隔逻辑代码块，这和注释同样重要。
